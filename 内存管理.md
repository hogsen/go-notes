# 栈内存

内存由编译器管理(申请，分配，释放)等，用于存放函数的参数、局部变量、返回值等。
函数执行完毕就释放内存
申请到栈的好处是，函数返回时直接释放，不会引起垃圾回收，对性能没影响。

# 堆内存

内存由开发者手动/编译器管理，对于 Go 这种有垃圾回收的，通常由 GC 来释放内存。
申请到堆上的内存会引起垃圾回收，频繁的垃圾回收，会导致垃圾回收压力过大，影响程序性能

# 内存在哪里分配

内存分配到哪里，由编译器决定。
如果变量可能会被外部引用，或者申请的内存过大，编译器就会在堆上分配内存。

```go
// 这个函数有返回值，编译器认为a后面还会用，函数返回之后不能释放内存，那么a就需要放在堆上
func F()[]int{
  a:=make([]int,0,10)
  b:=make([]int,0,20) // b 内存小，将它分配到栈上
  c:=make([]int.0.1000000) // c 内存大，将它分配到堆上
  d:=make([]int,0,len)  //d 对于这种不确定内存大小的也会分配到堆上
  return a
}
```

# 逃逸分析(确定变量在哪里)

如果一个变量的地址被传递到函数外部，或者它的生命周期超过了函数调用，
那么该变量就必须分配在堆上，以确保在函数返回后仍然可以访问它。

在实际编程中，有时候即使你希望一个变量分配在栈上，编译器可能还是会将其分配在堆上。
这是由编译器的优化策略和逃逸分析的局限性所决定的。

逃逸分析是在编译程序优化理论中的一种确定指针动态范围的方法，具体是指分析在程序的哪些位置能够访问到该指针。
其目的是确定一个变量到底要放在堆上还是栈上，具体规则如下所示

1. 变量是否有在其他区域（非局部）被引用。只要有被引用的可能，那么它一定分配到堆上。否则分配到栈上。
2. 变量是否有在其他区域（非局部）被引用。只要有被引用的可能，那么它一定分配到堆上。否则分配到栈上。

要在程序的编译阶段确立逃逸，而不是在运行时。
逃逸分析首先能够减少垃圾回收(GC)的压力，栈上的变量随着函数退出后被系统直接回收，不需要 GC 标记后再清除；
其次能够减少内存碎片的产生；最后能够减轻分配堆内存的开销，提高程序的运行速度。

- **escapes to heap：**
  这个表述强调的是变量的“逃逸”行为，即变量从原本应该分配在栈上的位置“逃逸”到了堆上。
  这通常发生在编译器进行逃逸分析时，发现变量的生命周期或可见性超出了当前函数或作用域的范围，
  因此需要将变量移动到堆上以延长其生命周期。

- **moved to heap：**
  这个表述则更直接地指出了变量的存储位置发生了变化，从栈内存移动到了堆内存。
  这通常是“escapes to heap”这一逃逸行为的直接结果。
  当编译器确定一个变量需要逃逸到堆上时，它就会在堆上为该变量分配内存，并将变量移动到那里。
- **can inline**
  编译器认为该函数可以被内联，内联（inlining）是一种优化技术，其中编译器将函数的调用替换为函数体本身的代码，以减少函数调用的开销。
- **inlining call**
  编译器已经决定将一个函数调用内联化，并且正在将函数的代码插入到调用点。

## 指针逃逸

返回局部变量的指针，这种情况就会发生逃逸
因外部引用而发生逃逸

```go
type Student struct {
	Name, Sex string
	Age       int
}
// 返回地址才会发生逃逸
func GetStudent(name, sex string, age int) *Student {
	s := new(Student)
	s.Name = name
	s.Age = age
	s.Sex = sex
	return s
}
func main() {
	GetStudent("张三", "男", 18)
}
//  go build -gcflags=-m
// new(Student) escapes to heap  这里局部变量发生了逃逸
```

## 栈空间不足而发生逃逸

```go
func GetSlice() {
	s := make([]int, 0, 1000)
	for i := range s {
		s[i] = i + 1
	}
}
func GetBigSilce() {
	s := make([]int, 0, 100000000) // 栈空间不足发生了逃逸
	for i := range s {
		s[i] = i
	}
}
func main() {
	GetSlice()
	GetBigSilce()
}

// make([]int, 0, 1000) does not escape
// make([]int, 0, 100000000) escapes to heap
```

## 动态类型逃逸

一定要确定类型和空间大小，不然可能会发生逃逸
fmt.Println 接收 any 类型的参数，导致 s 发生了逃逸

当函数参数或返回值类型为空接口时，编译器无法确定具体类型的大小和布局，因此可能会将相关变量逃逸到堆上。

```go
func main() {
	s := "hello"
	fmt.Println(s)
}
// s escapes to heap
```

## 外界变量引用了闭包函数

1. 闭包函数没有对外暴露，不会发生逃逸

```go
func bar() {
	a := 10
 	func() {
		a++
	}()
}
func main() {
	bar()
}
```

2. 外部变量引用了闭包函数，函数逃逸
   因为闭包函数被返回了，那么这个闭包函数以及它引用的外部变量都会跑到堆上

```go
func bar() func() {
	a := 10
	return func() {
		a++
	}
}

func main() {
	zar := bar()
	zar()
}
// func literal escapes to heap
//  moved to heap: a
```
