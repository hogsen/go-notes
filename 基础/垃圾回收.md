# 垃圾回收 GC

垃圾回收是一个守护线程，它的作用是监控各个对象的状态，识别并且丢弃不再使用的对象来释放和重用资源。

# GC 算法

经典的 GC 算法有三种：引用计数、标记-清除和复制收集
Go 语言中使用的垃圾回收机制是三色标记法配合写屏障(Write Barrier)和辅助 GC(Mutator Assist)，三色标记法是标记-清除法的一种增强版本。

1. 标记-清除
   原始的标记清除法分为标记和清除两个步骤。
   首先会暂停程序中所有正在运行的线程，然后标记被引用的对象，这个过程叫 STW(Stop the world)
   清除过程：回收没有被标记的对象，并恢复线程运行

有个问题：通过 STW 保证 GC 期间标记对象的状态不能变化，整个程序都要暂停，在外部看来程序就会出现卡顿现象

2. 三色表记法
   三色标记法是一种并发标记方法，它是描述追踪式回收器的一种有效的方法。三色标记法将对象分成黑色、灰色、白色 3 种类型

- 黑色：对象是根对象，或者该对象与它的子对象都被扫描过
- 灰色：对象本身已经被扫描，但是该对象的子对象还没有被标记完成。
- 白色：对象未被扫描，当扫描完成所有对象之后，剩下的白色对象为不可达对象，即垃圾对象。

# GC 调优

如果内存分配过快，垃圾过多，就会增加 GC 回收压力，为了加快 GC,可能会暂停用户线程，同时抢占用户线程进行垃圾回收，导致程序变慢影响性能。

1. 减少对象的分配，合理重复利用
2. 尽量避免 string 与[]byte 之间的转化
3. 尽量避免使用“+”连接字符串。针对它的每一个操作都会创建一个新的 string。
4. 如果是大量小文本拼接，则使用 strings.Join；如果是大量大文本拼接，则使用 bytes.Buffer。
5. 使用 go tool pprof 来分析堆分配和 GC 行为。
6. 调整 GC 百分比：GOGC 默认是 100，达到这个值就会触发 GC
7. 减少逃逸
8. 减少全局变量和长周期对象
9. 手动释放内存，将对象设为 nil,或者手动触发 GC runtime.GC()

# GC 触发条件

一个是内存阈值和定时
当新分配的内存与正在使用的内存比例超过 gcprecent 时就会触发回收。
如果达不到阈值就默认 2min 触发一次

也就是说你可分配的内存越大，默认定时越长，GC 频率就越小

# 临时实例池（内存池）

目的是存放预先分配但是暂时不使用的实例化对象，
Go 程序在需要用到这些实例时直接从实例池中获取，而不用频繁地向系统申请和释放内存。

```go
// 初始化实例池
var strPool = sync.Pool{
	New: func() any {
		return "hello"
	},
}

func main() {
	// 获取实例
	str := strPool.Get()
	// 操作实例
	fmt.Println(str)
	// 放回实例
	strPool.Put(str)
}
```
